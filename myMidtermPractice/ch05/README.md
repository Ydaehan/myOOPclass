# 05.Class, Object, Method
## 객체 지향 프로그래밍 이란?
* 객체 지향 프로그래밍(OOP: object-oriented programming)은 
  우리가 살고 있는 실제 세계가 객체(object)들로 구성되어 있는 것과 비슷하게,
  소프트웨어도 객체로 구성하는 방법이다.

## 객체
### 객체(Object)는 그 이름에서 볼 수 있듯이, 객체 지향 기술의 핵심 개념이다.
- 상태
  - 객체의 상태(state)는 객체의 속성이다.
    ex) 텔레비전 객체의 경우, 상태는 채널번호, 볼륨, 전원상태 등이다.
- 동작
  - 객체의 동작(behavior)은 객체가 취할 수 있는 동작(기능)이다.
    ex) 텔레비전을 예로 들면, 켜기, 끄기, 채널 변경하기,
        볼륨 변경하기 등이 여기에 해당된다.
### 객체의 상태와 동작은 S/W에서는 각각 필드와 메소드로 표현할 수 있다.
- 필드
  - 객체 안의 변수
  - 객체의 상태를 저장한다
- 메소드
  - 객체의 동작을 나타내는 부분
  - 특정한 작업을 수행한다
**즉 객체는 필드와 메소드로 이루어져 있는 소프트웨어의 묶음**

## 캡슐화
### 관련된 데이터와 알고리즘이 하나의 묶음으로 정리 되어 있어야한다.
#### 객체 지향 프로그래밍에서는 이것을 캡슐화(encapsulation)라고 부른다.
- 캡슐화는 용어 그대로 서로 관련된 데이터와 알고리즘을 캡슐에 넣어서 포장하는 것을 의미한다.
- 객체(object)가 바로 하나의 캡슐이다.

### 캡슐화의 목적
1. 서로 관련되어 있는 데이터와 알고리즘을 묶는 것이다.
   - 관련 있는 데이터와 알고리즘이 묶여 있으면 사용하기가 매우 편리하다.
2. 객체를 캡슐로 사서 객체의 내부를 보호하는 것이다.
   - 즉 객체의 실제 구현 내용을 외부에 감추는 것이다
이것을 **정보 은닉(information hiding)** 이라고 한다.

## 상속
- 기존의 코드를 재활용하기 위한 기법으로
- 이미 작성된 클래스(부모 클래스)를 이어 받아서 새로운 클래스(자식 클래스)를 생성하는 기법이다
- 자식 클래스는 부모 클래스의 모든 속성과 동작을 물려받는다.
- 추가로 만약 자식 클래스에만 필요한 기능이 있다면 추가 or 변경할 수 있다.
  - 다른 사람이 제공한 클래스는 아무래도 자신의 문제에 맞지 않는 경우가 종종 있다.
  이런 경우에 상속을 사용하여서 다른 사람의 클래스를 상속받은 후에 자신이 필요한 부분을
  변경하여서 사용할 수 있다.
  **상속은 기존의 코드를 재사용하는 강력한 기법이다.**
  
## 다형성
**다형성이란 객체가 취하는 동작이 상황에 따라서 달라지는 것을 의미한다.**
- 자바에서는 서로 다른 타입에 속하는 객체들이 같은 이름의 멤버 함수에 응답하여서 서로
  다른 동작을 보여주는 것이 가능하다.
- 프로그래머는 객체의 타입을 미리 알 필요가 없고 객체의 정확한 동작은 실행 시간에야
  결정된다
- 다형성을 사용하게 되면 실제 동작은 다르더라도 개념적으로 동일한 작업을 하는 멤버 함수
  들에 똑같은 이름을 부여 할 수 있으므로 코드가 더 간단해진다. 

## 추상화
*추상화(abstraction)*는 불필요한 정보는 숨기고 중요한 정보만을
표현함으로써 **프로그램을 간단히 만드는 기법이다.**


# 클래스 기초
## 클래스란?
- 설계도에 의하여 객체들이 생성되는데 그 객체에 대한 설계도를 *클래스(class)*라고 한다.
  - 특정한 종류의 객체들을 찍어내는 *형틀(template)* 또는 *청사진(blueprint)*이라고도 할 수 있다.
- 클래스로부터 만들어지는 각각의 객체를 그 클래스의 *인스턴스(instance)*라고 한다
### 인스턴스
- *인스턴스(instance)*는 사례라는 의미이다.
#### 객체라는 용어가 있는데 인스턴스라는 새로운 용어를 사용하는 이유는 무엇일까?
- 그것은 객체가 너무 광범위한 의미를 가지고 있기 때문이다.
- 특정한 클래스로부터 생성된 객체를 그 클래스의 *인스턴스(instance)*라고한다.

## 클래스의 구조
- 클래스는 객체의 형태를 정의하는 *틀(template)*과 같은 것이다.
- 클래스 안에는 필드와 메소드들이 정의된다
- 이들은 클래스의 *멤버(member)*라고 불린다.
- 필드는 객체의 상태를 나타내고 메소드는 객체의 동작을 나타낸다.
- *필드*는 객체 안에 정의된 변수이다.
  - 따라서 변수를 정의하듯이 자료형과 변수 이름을 적어주면 된다.

**잘 설계된 클래스는 오직 하나의 논리적인 개념만을 정의하여야 한다.**
  => 즉, 서로 관련있는 정보들만 클래스 안에 정의되어야 한다.

- 이제까지 우리가 사용해온 클래스는 *main()* method 만을 가지고 있었다.
- 일반적인 클래스라면 *main()*을 반드시 가질 필요가 없다.
  **특정한 클래스가 프로그램의 시작점이 되는 경우에만 클래스 내에 main() method가 필요하다.**

## 클래스 정의
- 클래스 이름의 첫 글자는 일반적으로 *대문자*로 한다.
ex) 
Television.java
라는 클래스가 존재할 때 이 클래스가
<!-- public class Television {
      int channel;
      int volume;
      boolean onOff;
    } -->
이러한 형태의 필드를 가질 때

- 컴파일러의 입장에서 보면, 새로운 클래스를 정의하는 것은
  프로그램에서 사용할 수 있는 새로운 자료형(type)을 하나 추가하는 것과 같다.
**컴파일러는 Television class 도 int처럼 하나의 자료형으로 간주함**

## 객체 생성
- 클래스 != 객체
- JAVA 에서는 클래스 외부에 문장을 입력할 수 없다. => 모든 문장은 반드시 클래스 내부에 들어가야 함
**자바에서 객체를 생성하려면 단 한가지 방법만 있다. => 바로 *new 연산자* 를 사용하는 것이다.**

  ex)
      Television *(1) tv* *(3)=* *(2) new Television*();
      (1) 참조 변수 선언
          - Television class의 객체를 참조할 수 있는 변수tv를 선언함
      (2) 객체 생성
          - new 연산자를 이용하여 Television class의 객체를 생성하고 객체의 참조값을 반환한다.
          - new 연산자는 *동적 메모리 할당*을 이용하여서 객체를 생성한다.
            **즉, 실행 시간에 메모르에 객체를 생성한다는 의미이다**
          - new 연산자는 객체의 참조값을 반환한다.
          => 참조값은 결국 객체가 생성된 메모리 주소가 된다.
      (3) 참조 변수와 객체의 연결
          - 생성된 새로운 객체의 참조값(주소값)을 참조 변수 tv에 저장한다.

  - 위의 문장은 다음과 같이 2개의 문장으로 분리 될 수 있다.
  Television tv;
  tv = new Television;
  -  먼저 객체의 참조 변수를 선언한 후
  -  그 참조 변수에 Television 객체를 생성하고 참조변수 tv에 참조값(생성된 객체의 주소값)을 저장한다.

## 참조 변수
- 자바에서는 변수를 *primitive variable(기초 변수)* 와 *reference variable(참조 변수)* 로 나눌 수 있다.
*기초 변수*
  - int, float, char등의 기초 자료형의 값을 저장하는 변수이다.
    - 이들 기초 변수에는 실제 데이터값이 저장된다.
*참조 변수*
  - 객체를 참조할 때 사용되는 변수
  - 객체의 참조값이 저장된다.
  - 참조값은 일반적으로 객체의 주소값이다. **참조 변수에 객체가 직접 저장되는 것은 아니다!!**

## 객체 멤버 접근하기
- 객체의 필드나 메소드를 참조하려면 참조 변수에 *멤버 연산자(.)*를 사용하면 된다
**최근에는 필드 라는 이름 대신 인스턴스변수(instance variable)라는 용어로 많이 사용된다.**

### 객체는 여러 개 생성될 수 있다.

## 참조 변수와 대입 연산
- 기초 변수의 값을 다른 변수에 대입하게 되면 변수의 값이 **복사되어서 전달이 된다**
- 참조변수의 경우 상황이 달라진다.
  ex) 
      Television tv1 = new Television();
      Television tv2 = tv1;
- 이처럼 참조변수를 복사하면 참조값이 복사되어서 동일한 객체를 참조하게 된다.

## 쓰레기 수집기
- Java에서 객체들은 new연산자에 의하여 *히프 메모리(heap memory)*에서 할당된다.
  *히프 메모리*는 컴퓨터에서 사용 가능한 메모리를 모아 놓은 곳이다.
  - 메모리는 무한하지 않기 때문에 이들 히프 메모리는 언제든 고갈될 수 있다.
  - 따라서 자바 시스템에서 사용되지 않는 객체들을 삭제하여 메모리를 확보하는 것이 필요하다.
  다른언어 에서는 프로그래머가 직접 객체의 삭제를 책임져야 하지만 자바에서는 *자동 메모리 수거 시스템*을 사용하는데 이것을 *쓰레기 수집(garbage collection)*이라고 한다.

- 그렇다면 *garbage collection*은 어떻게 객체가 사용되어지고 있는지 아닌지를 파악하는 것일까?
- 모든 객체는 참조 변수를 통해야만이 사용할 수 있다.
- 만약 객체에 대한 참조가 전혀 없다면 객체는 사용 자체가 불가능하다.
**따라서 어떤 객체를 참조하는 변수가 전혀 없다면 그 객체는 없애도 좋은 것이다.**

## 클래스와 소스파일
**자바에서는 일반적으로 하나의 소스 파일에는 하나의 클래스만을 담는 것이 원칙이다.**
- 즉, Television class 는 Television.java에 저장되고 TelevisionTest 클래스는 TelevisionTest.java에 저장되어야 한다.
- 컴파일러는 2개의 파일을 컴파일 하여서 2개의 클래스파일 Television.class와 TelevisionTest.class 파일을 생성한다

**하지만 하나의 소스파일에 여러 개의 클래스도 넣을 수 있다.**
- 이 경우에는 소스 파일에 포함된 여러 개의 클래스들 중에서 public 앞에 붙어 있는 클래스의 이름과
  소스파일의 이름이 일치하여야 한다. (eclipse 환경에서)


## method
### 대부분의 클래스 안에 정의된 함수
- 클래스 안에 선언된 **특정한 작업을 수행하는 문장들의 모임**이다.
- 각 메소드는 오직 하나의 작업만을 하도록 *작성하는편이 좋다*
- 각 메소드는 이름을 가지고 있으며 메소드를 호출할 때는 해당 메소드의 이름을 사용하여 호출한다.
- main()이라는 이름은 프로그램의 실행이 시작되는 중요한 메소드이므로 사용하지 않아야한다.
- 자바의 키워드도 메소드의 이름으로 사용하면 안된다.

### 메소드의 종료
- 메소드가 종료되는 2가지의 조건이 있다.
  1. 메소드 안의 문장들을 실행하다가 } 를 만나면 종료된다.
  2. 메소드 안의 문장들을 실행하다가 *return문*이 실행되면 종료된다.
    - *return문*은 어떤 값을 반환할 수도 있고 아니면 반환값 없이 종료할 때도 사용된다.
      - 반환값 없이 종료할 때는 *return;* 이라고 적어주면 된다.

### 메소드의 반환값
- 메소드는 자신을 호출한 코드에 값을 반환할 수 있다.
- 메소드는 return 문장을 사용하여서 값을 반환한다.
- void로 선언된 메소드는 값을 반환하지 않는다.
- 메소드는 반드시 return 문을 가져야 하는 것은 아니지만 일반적으로 return문을 가진다.
  

### 인수와 매개변수
- 메소드를 호출할 때는 값도 같이 전달 할 수 있다.
- 메소드 호출시 전달하는 값을 *인수(argument)*라고 하고 메소드에서 값을 받을 때 사용하는 변수를 *매개변수(parameter)*라고한다.
  -*매개변수*는 콤마로 분리된 변수 선언이다.
  **메소드의 이름 짓기**
    - 메소드는 어떤 이름이라도 가질 수 있지만
    - 관습적으로 메소드의 첫 글자는 소문자로 한다.
    - 그리고 동사로 시작한다, 동사 다음에는 명사나 형용사가 올 수 있다.
    - 만약 여러 단어로 된 이름이라면 두 번째 단어의 첫 글자는 대문자가 된다.
## 메소드 오버로딩
- *메소드 오버로딩* 이란 이름이 같은 메소드를 여러 개 정의하는 것이다.
- 다만 각각의 메소드가 가지고 있는 매개 변수는 달라야 한다.
- 자바에서는 같은 이름의 메소드가 여러 개 존재할 수 있다.
  - 이것을 *메소드 오버로딩 (method overloading)* 이라고한다.
  - 프로그래밍에서는 "중복 정의" 혹은 "다중 정의" 라는 의미로 사용한다.

- 동일한 이름을 사용하려면 조건이 하나 있는데
**매개 변수의 개수나 자료형** 을 다르게 해야 한다는 것이다.
  *반환형만 다르게 하는 것은 인정되지 않는다.*
**반드시 매개변수의 개수가 다르거나 매개 변수의 자료형이 달라야한다.**

*메소드 오버로딩은 왜 유용할까?*
- 만약 메소드 오버로딩을 사용하지 않는다면
  데이터의 종류에 따라서 계산하는 메소드의 이름을 전부 다르게 지어야 한다.
  - 예를 들어 정수를 제곱하는 메소드는 square_i(), 실수를 제곱하는 메소드는 square_d()
    와 같이 서로 다른 이름을 사용하여야하는 불편함이있다.
  - 메소드 오버로딩을 사용하면 이러한 메소드들을 같은이름으로 편하게 사용 가능하다.

**메소드 오버로딩은 주의 깊게 사용되어야 한다. 메소드 오버로딩은 코드를 읽기 어렵게 만들 수 있기 때문이다.**
### 메소드 오버로딩의 대표적인 예시
- void println(boolean x)
- void println(char x)
- void println(double x)
- void println(String x)
-         .
-         .
-         .
*우리가 자주 쓰던 println() 메소드 또한 어던 데이터도 출력할 수 있도록 오버로딩 되어 있다.*

## UML
- OOP에서도 프로그래머들은 애플리케이션을 구성하는 클래스들 간의 관계를 그리기 위하여 클래스 다이어그램
  (class diagram)을 사용한다.
  - 가장 대표적인 class diagram 표기법은 UML(Unified Modeling Language)이다.
    *사실 UML은 클래스만을 그리는 도구는 아니고 객체지향설계 시에 사용되는 일반적인 모델링언어라고 할 수 있다.*
    **UML을 사용하면 소프트웨어를 본격적으로 작성하기 전에 구현하고자 하는 시스템을 시각화하여 검토할 수 있다.**
### UML의 구성요소
- **클래스 다이어그램**
- 객체 다이어그램
- 상태 다이어그램
- 시퀸스 다이어그램
  등과 같은 많은 다이어 그램이 있다.

**UML의 예**
// --------------------
// |Car               | <!-- 클래스의 이름을 적어준다 -->
// --------------------
// |-speed  : int     | <!-- 클래스의 속성을 나타낸다 -->
// |-gear   : int     | <!-- 즉 필드를 적어준다 -->
// |-color  : String  |
// --------------------
// |+speedUp()  : void| <!-- 클래스의 동작을 나타낸다 -->
// |+speedDown(): void| <!-- 즉 메소드를 적어준다 -->
// --------------------

- 필드에 대해서는 자료형을 표기할 수 있고,
  메소드에 대해서는 매개변수와 반환형을 표기 할 수 있다.
- 필드의 자료형은 이름 뒤에 : 기호를 쓰고 자료형을 적으면 된다.
- 필드나 메소드의 이름 앞에는 *가시성 표시자(visibility indicator)*가 올 수 있다.
* + : public
* - : private

### 의존 관계
- 점선의 열린 화살표는 의존을 나타낸다.
#### 의존(dependency)란?
**하나의 클래스가 다른 클래스를 사용하는 관계이다.**

## String 클래스 사용
### 문자열은 객체
- 문자열(String)은 프로그램에서 많이 사용되는 중요한 자료형이다.
- 문자열은 자바에서 기초 자료형이 아니다
  *즉, 자바 언어에서는 문자열을 저장할 수 있는 기초 자료형은 없다.*
  그러나 문자열을 저장하고 처리하는 *String* 이라는 클래스가 존재한다.
**정수나 실수와는 다르게 문자열은 객체라는 점을 잘 기억하여야 한다.**

### 객체의 생성
- 자바에서 객체를 생성하는 방법은 단 하나뿐
  *new*
ex) `String s = new String("Hello World!");` <!-- 선언과 동시에 초기화 -->
    이 예시를 실행하면 String객체가 하나 생성된다
    여기서 's'는 참조 변수로 생성된 객체를 가리키는 변수
    *기초 변수*는 값을 변수 안에 저장하지만
    *참조 변수*는 **객체의 주소**가 저장된다.

### String class 메소드
*char*    : *charAt(int index)*                     <!-- 지정된 인데스에 있는 문자를 반환한다 -->
*int*     : *compareTo(String anotherString)*       <!-- 사전적 순서로 문자열을 비교한다 앞에 있으면 -1 
                                                    / 같으면 0 / 뒤에 있으면 1이 반환된다 -->
*String*  : *concat(String str)*                    <!-- 주어진 문자열을 현재의 문자열 뒤에 붙인다 -->
*boolean* : *equals(Object anObject)*               <!-- 주어진 객체와 현재의 문자열을 비교한다 -->
*boolean* : *equalsIgnoreCase(String anotherString)*<!-- 대소문자를 무시하고 비교한다 -->
*boolean* : *isEmpty()*                             <!-- length()가 0이면 true를 반환한다 -->
*int*     : *length()*                              <!-- 현재 문자열의 길이를 반환한다 -->
*String*  : *replace(char oldChar, char newChar)*   <!-- 주어진 문자열에서 oldChar를 newChar로 
                                                    변경한, 새로운 문자열을 생성하여 반환한다-->
*String*  : *subString(int beginIndex,int endIndex)*<!-- 현재 문자열의 일부를 반환한다 -->
*String*  : *toLowerCase()*                         <!-- 문자열의 문자들을 모두 소문자로 변경한다 -->
*String*  : *toUpperCase()*                         <!-- 문자열의 문자들을 모두 대문자로 변경한다 -->

- String 객체는 일단 생성되면 그 내용은 변경이 불가능하다
  => 위의 메소드 중에 일부 메소드는 변경된 문자열을 담은 새로운 객체를 생성하여 반환한다
- 또한 문자열 내 첫 인덱스는 0으로 시작한다

### 문자열 상수
- 문자열 상수는 "Hello World!"와 같이 ""를 사용하여 표현된다.
- 문자열 상수도 String class의 객체로 저장된다. => 메소드를 문자열 상수를 통해서도 사용할 수 있다.
  ex) 
  `int size = "Hello World".length();  // 문자열의 크기`
  `System.out.println(size);           // 12가 출력된다.`

### 문자열의 결합
- 두 개의 문자열은 + 연산자를 이용하여 결합될 수 있다
- + 연산자가 문자열에 적용되는 경우, **결합 연산자(concatenation operator)** 라고도 불린다.

### 수치값을 문자열로 변환하는 방법
- 자바에서는 문자열과 기초 자료형 변수를 결합하게 되면 자동적으로 기초 자료형을 문자열로 변환한다.
  이 때 수치값이 문자열에 +연산자로 합해지는 경우에만 문자열로 변환되어서 결합된다

### 랩퍼 클래스
#### 문자열을 수치값으로 변환하는 방법
기초자료형 => 랩퍼클래스
*byte*    => *Byte*
*short*   => *Short*
*int*     => *Integer*
*long*    => *Long*
*float*   => *Float*
*double*  => *Double*
*char*    => *Character*
*boolean* => *Boolean*
*void*    => *Void*
- 이처럼 랩퍼 클래스는 기초 자료형을 클래스로 만들고 싶은 경우에 사용하면 된다.
- 문자열을 수치값으로 변환해주는 메소드도 가지고 있다

- 랩퍼 클래스는 여러가지 유용한 메소드도 제공한다
