# 06.클래스와 메소드 심층 탐구
## 접근 제어
- 접근 제어란 클래스의 멤버에 접근하는 것을 제어하는 것

### 자바의 접근 제어 지정자
- 멤버의 접근 제어에는 3가지의 지정자로 이루어진다.
- `public`, `private`, `protected`가 바로 그것이다.
- 아무것도 안 붙이면 `default` 접근 제어 지정자 이다

*접근 제어를 선택하는 팁*
- 일반적으로 멤버에 대해서는 가장 업격한 접근 제어자인 `private`를 선택하는 것이 좋다
- *상수를 제외하고는 필드에 `public`을 사용하면 안 된다.*
  외부 클래스들이 `public` 필드를 자유롭게 사용하면 코드를 변경하기 힘들어진다.

## 접근자와 설정자
- `private` 를 이용하여 OOP의 개념 중 하나인 *정보 은닉*을 할 수 있다.
- `private` 를 사용하면 외부로부터의 접근이 차단된다.

### 하지만 만약 저장된 필드 값이 꼭 필요한 경우에는 어떻게 하는것이 좋을까?
- *접근자 (getter)*
  - 필드 값을 반환
- *설정자 (setter)*
  - 필드 값을 설정

**사용 이유**
- 접근자와 설정자를 사용해야만 나중에 클래스를 업그레이드 할 때 편하다.
- 접근자에서 매개 변수를 통하여 잘못된 값이 넘어오는 경우, 이를 사전에 차단할 수 있다.
- 필요할 때마다 필드값을 계산하여 반환할 수 있다.
- 접근자만을 제공하면 자동적으로 읽기만 가능한 필드를 만들 수 있다.

## 생성자 (constructor)
**생성자는 객체가 생성될 때 객체를 초기화하는 특수한 메소드**
- 생성자는 객체가 생성될 때 `new`에 의하여 호출된다.

### 매개 변수를 가지는 생성자
- 일반적인 생성자는 몇 개의 매개 변수를 가진다
- 매개 변수는 메소드의 매개 변수와 동일한 기능을 한다.

### new 연산자와 생성자
- 구조
  `refVariable = new ClassName(argument);`

*개발자가 생성자를 정의 하지 않아도 자바에서 모든 클래스는 default 생성자를 가진다*
- 기본 생성자에서는 필드가 int와 같은 수치형 변수라면 0으로, 참조형 변수라면 null로, boolean형 변수면 false로 초기화 한다.
- 생성자는 실제로 객체를 생성하는 메소드는 아니며 객체를 초기화하는 메소드이다
  => 따라서 `생성자`를 `구성자`라고 번역하기도 한다.

## 생성자 오버로딩
- 메소드처럼 생성자도 오버로딩 될 수 있다.
- 생성자가 여러 개 있다면 다양한 방법으로 객체를 생성할 수 있다.

### this 로 현재 객체 나타내기
- 메소드나 생성자에게 this는 현재 객체를 나타낸다.
- this를 이용하여서 현재 객체의 어떤 멤버도 참조할 수 있다.
- 또 this() 와 같이 this 뒤에 ()을 붙이면 생성자 호출이 된다.

### this로 생성자 호출하기
- 하나의 클래스 안에서 생성자는 여러 개 작성될 수 있다.
- 생성자의 매개 변수만 다르면 된다
- 실제로 자바에서는 매개 변수만 다르면 동일한 이름의 메소드를 여러 개 생성할 수 있다
- 이것을 *메소드 오버로딩*이라고 부른다
- 생성자도 메소드의 일종이기 때문에 오버로딩이 가능하다
- 생성자 안에서는 `this()`를 사용하여 다른 생성자를 호출할 수 있다
- 이것은 *명시적인 생성자 호출*이라고 불린다.

## 다른 필드 초기화 방법
### 필드 선언시 초기화
- 클래스 안에 필드를 선언할 때, 초기값을 줄 수 있다.
**배열을 채우는 반복 루프나 오류 처리와 같은 문장들을 넣을 수 없다.**
- 필드 들은 생성자에서 초기화 하는 편이 좋다
  
### 인스턴스 초기화 블록
- 구조
  {
    <!-- 초기화 구문 -->
  }

- 자바 컴파일러는 정적 초기화 블록을 모든 생성자에 복사한다.
- 따라서 여러 생성자가 동일한 코드를 공유 할 수 있다.

*초기화 블록은 생성자에 복사됨*
=> 어떤 것이 먼저 실행이 될까?
  - 자바 컴파일러는 인스턴스 초기화 블록을 생성자의 맨 첫 번째 문장으로 복사한다.
  - 따라서 생성자가 호출되어 실행되면 바로 인스턴스 초기화 블록이 실행되고 생성자의 나머지 문장들이 실행된다

*왜 인스턴스 초기화 블록을 사용할까?*
=> 인스턴스 초기화 블록은 어떤 생성자가 선택되든 상관없이 어떤 공통적인 코드를 실행하고자 할 때 편리하다.
+ 무명 클래스(이름이 없는 클래스)에서 초기화를 할 때도 필요하다.

## 메소드로 객체 전달하고 반환하기
- 자바에서 인수에서 매개 변수로 값이 전달되는 방법은 *call by value*(값에 의한 호출) 이다.
  - *call by value*는 인수의 값이 *복사* 되어 매개 변수로 전달되는 방식이다.
    - 하지만 인수가 기초 변수인 경우와 인수가 참조 변수인 경우에는 상당한 차이가 있다.

### 기초 변수가 전달되는 경우
- 전달하는 인수가 기초 변수인 경우에는 인수의 값이 매개 변수로 복사된다.

### 객체가 전달되는 경우
- 객체를 메소드로 전달하게 되면 객체가 복사되어 전달되는 것이 아니고 참조 변수의 값이 복사되어서 전달된다.
  - 이 때 참조 변수의 값은 객체의 주소값을 저장하고 있으며 복사되는 값은 주소값이 전달된다.

### 배열이 전달되는 경우
- 배열을 받아서 처리하는 메소드는 상당히 자주 등장함
  ex) 
  - 배열의 원소를 출력하는 메소드
  - 배열 원소들의 평균을 구하는 메소드
  *이들 메소드는 모두 배열을 매개 변수로 받아야한다*
- 자바에서는 배열도 *객체*이다
- 따라서 배열이 전달되는 경우에도 객체가 전달되는 것과 동일하게 처리
즉 배열이 전달되는 것이 아니라 *배열을 가리키는 참조값이 복사*되고 **메소드에서 매개 변수를 통하여**
**배열을 변경하면 원본 배열이 변경** 된다,

## 정적 멤버
- 자바에서는 객체를 통하지 않고 사용할 수 있는 멤버를 생성하는 것이 가능하다.
- 이러한 멤버를 **정적 멤버(static member)** 또는 **클래스 멤버(class member)**라고 한다.
- 멤버를 정의할 때 앞에 static을 붙이면 정적 멤버가 된다.

### 인스턴스 멤버 VS 정적 멤버
- 인스턴스 멤버
  - 동일한 클래스를 이용하여 많은 객체들이 생성될 때 각각의 **객체(instance)**들은 자신만의 변수를 가짐
  - 이들 변수는 인스턴스마다 별도로 생성되기 때문에 **인스턴스 변수(instance variable)** 라고도 한다
- 정적 변수
  - 경우에 따라 모든 객체에 공통인 변수가 필요한 경우도 존재
  - *정적 변수*는 하나의 클래스에 하나만 존재
  - *정적 변수*는 객체보다는 클래스와 연결되어 있다.
  - *정적 변수*는 *클래스 변수*라고도 한다.

### 정적 메소드
- 구조
  `클래스이름.메소드이름(인수1, 인수2, ...)`
- 예
- Math class의 각종 수학 메소드들
  - 일반적으로 객체를 생성할 필요가 없다
  - 클래스 이름으로 메소드들을 호출함 => 정적 메소드들로 이루어져 있다.

**주의할 점**
1. **객체가 생성되지 않은 상태에서 호출되는 메소드** 이므로 객체 안에서만 존재하는
   `인스턴스 변수`는 사용할 수 없으며 `정적 변수`와 `지역 변수`만을 사용할 수 있다.
2. `정적 메소드`에서 `인스턴스 메소드`를 호출하면 오류 -> `인스턴스 메소드`는 **객체가 생성되어야만 사용할 수 있기 때문**이다.
3. `정적 메소드`에서 `정적 메소드`를 호출하는 것은 가능
   *this 키워드를 사용할 수 없다* -> this가 참조할 인스턴스가 존재하지 않음

### 상수
- 상수를 정의할 때 `static`과 `final` 수식어를 동시에 사용하는 경우가 많다
- 클래스 변수는 모든 객체가 공유하는 정보를 나타내는 데 사용 되며 대표적인 예 가 상수이다.
- `static`을 정의하여 클래스 변수로 정의하는 것이 바람직


### 정적 초기화 블록
- *정적 초기화 블록*은 중괄호 `{}` 로 감싸여진 코드 블록
- `정적 변수`를 초기화 하는데 사용됨
- *인스턴스 초기화 블록*과 다르게 앞에 `static`이 붙음
- 정적 초기화 블록 없이 정적 변수의 초기화는 정적 메소드로 작성한다
**장점**
- 클래스 변수를 다시 초기화 할 필요가 있을 때 소스코드에서 여러개를 작성할 수 있다.


## 내장 클래스
- 자바에서는 클래스 안에서 클래스를 정의할 수 있다.

**외부 클래스(outer class)**
- 내부에 클래스를 가지고 있는 클래스
**내장 클래스(nested class)**
- 클래스 내부에 포함되는 클래스

### 내장 클래스의 종류
- 정적 내장 클래스
  - `static`이 붙어 내장되는 클래스
- 비정적 내장 클래스
  - `내부 클래스(inner class)`
    - 클래스의 멤버처럼 선언되는 내장 클래스
      - 접근 지정자
        - `public`
        - `private`
        - `protected`
        - `package(default)`
    - 외부 클래스의 인스턴스 변수와 메소드를 전부 사용할 수 있다.
    - **private로 선언되어 있어도 접근이 가능하다** << 최대 장점이다.
  - `지역 클래스(local class)`
    - 메소드의 몸체 안에서 선언되는 내장 클래스
    - **접근 제어 지정자를 가질 수 없다**
    - `abstract` or `final` 로만 지정할 수 있다. 
  - `무명 클래스(anonymous class)`
    - 수식의 중간에서 선언되고 바로 객체화 되는 크래스

### 중첩 클래스를 사용하는 이유
1. **내장 클래스**는 외부 클래스의 멤버가 private가 선언되어 있더라도 접근할 수 있다.
2. **내장 클래스**는 외부에서 보이지 않는다. 즉 철저하게 감춰진다.
3. **무명 클래스**는 `콜백 메소드(callback method)`를 작성할 때 아주 편리하다.